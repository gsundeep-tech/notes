<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Graph - Sundeep Notes</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Graph";
        var mkdocs_page_input_path = "ds_and_algo/graph.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Sundeep Notes
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">DS & Algo</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../binary_search/">Binary Search</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../trees/">Trees</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../sqrt_decomposition/">Square Root Decomposition</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../prefix_sum/">Prefix Sum</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../two_pointers/">Two Pointers</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">System Design</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../system_design/useful_links/">Useful Links</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Sundeep Notes</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
      <li>Graph</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <p>Union Find</p>
<pre><code class="language-python">
class UnionFind:
    def __init__(self, size):
        self.root = [i for i in range(size)]

    def find(self, x):
        if x == self.root[x]:
            return x
        self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x, y):
        parentX = self.find(x)
        parentY = self.find(y)
        if parentX &lt; parentY:
            self.root[parentY] = parentX
        else:
            self.root[parentX] = parentY

    def connected(self, x, y):
        return self.find(x) == self.find(y)

</code></pre>
<p>Using Ranking - more optimized way</p>
<pre><code class="language-python">class UnionFind:

    def __init__(self, size):
        self.root = [i for i in range(size)]
        self.rank = [1] * size

    def find(self, x):
        if self.root[x] == x:
            return x

        self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self, x, y):
        parentX = self.find(x)
        parentY = self.find(y)
        if parentX != parentY:
            if self.rank[parentX] &gt; self.rank[parentY]:
                self.root[parentY] = parentX
            elif self.rank[parentY] &gt; self.rank[parentX]:
                self.root[parentX] = parentY
            else:
                self.root[parentY] = parentX
                self.rank[parentX] += 1

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

</code></pre>
<p>Minimum Spanning Tree
1. Krushkal's Algo
2. Prim's Algo</p>
<p>Krushkal's Algorithm
krushkal's Algorithm is based on the union find. we sort all the edges based on the weight and add to the union find if the edges doesn't form a cycle. Cycle can be indentified if two nodes has the same parent. Once we have added all the edges we'll get the requirement minimum spanning tree</p>
<pre><code class="language-python">
class UnionFind:
    def __init__(self, size):
        self.parent = [i for i in range(size)]
        self.rank = [1] * size

    def find(self, x):
        while x != self.parent[x]:
            x = self.parent[x]
        return x

    def union(self, x, y):
        parentX = self.find(x)
        parentY = self.find(y)

        # cycle detected
        if parentX == parentY:
            return False

        if self.rank[parentX] &lt; self.rank[parentY]:
            self.parent[parentX] = parentY
        elif self.rank[parentY] &lt; self.rank[parentX]:
            self.parent[parentY] = parentX
        else:
            self.parent[parentY] = parentX
            self.rank[parentX] += 1
        return True


def minimum_spanning_tree(num_of_nodes, edges):
    &quot;&quot;&quot;
    num_of_nodes: total num of nodes
    edges: a tuple in the format of (src, dest, wt) 
    &quot;&quot;&quot;
    edges = sorted(edges, key=lambda x: x[2])

    uf = UnionFind(size=num_of_nodes)
    spanning_tree_edges = []
    for (src, dest, wt) in edges:
        if uf.union(src, dest):
            spanning_tree_edges((src, dest, wt))

    return spanning_tree_edges

</code></pre>
<p>Traversal 
1. BFS
2. DFS</p>
<pre><code class="language-python">
def bfs(graph, source=(0, 0), destination=(0, 0)):
    &quot;&quot;&quot;
    Graph dict[list]: Graph is passed as a adjacency list

    &quot;&quot;&quot;
</code></pre>
<p>Shortest Path
1. Dijkstra's Algo
2. A Star
3. Bidirectional BFS</p>
<h2 id="1-dijkstras-algo">1. Dijkstra's Algo</h2>
<p>Dijkstra's Algorithm is used to find the shortest distance from a given source in a weighted graph without negative edges
Note: It works only on the weighted graph without negative edges, for negative edges we need to use the Bellman Ford Algorithm</p>
<p>Problem: Given a graph and a source vertex in the graph, find the shortest paths from the source to all vertices in the given graph</p>
<pre><code class="language-python">
def single_source_shortest_path_for_adjacency_list(graph, source):
    &quot;&quot;&quot;
    graph: Adjacency list with the (node, weight)
    source: source node

    Reference: 
        1. https://www.tutorialspoint.com/Dijkstra-s-Algorithm-for-Adjacency-List-Representation
        2. https://www.scaler.com/topics/data-structures/dijkstra-algorithm/
    &quot;&quot;&quot;
    num_nodes = len(graph)

    distance = {}
    distance[source] = 0

    visited = {}
    prev = [None] * num_nodes
    heap = [(0, source)]

    while len(heap) &gt; 0:
        dist, curr_node = heapq.heappop(heap)

        if curr_node in visited:
            continue

        visited[curr_node] = True

        for adj_node, weight in graph.get(curr_node):

            if adj_node in visited:
                continue

            if dist + weight &lt; distance.get(adj_node, float('inf')):
                distance[adj_node] = dist + weight
                heapq.heapappend(heap, (adj_node, dist + weight))
                prev[adj_node] = curr_node

    print(distance) # shortest distance from the source to all nodes
    print(prev) # path to achieve that shortest distance

def single_source_shortest_path_for_adjacency_matrix(graph, source):
    &quot;&quot;&quot;
    graph: Matrix with weights as the values and indexes would be the nodes
    source: source node
    &quot;&quot;&quot;
    rows_length = len(graph)
    cols_length = len(graph[0])

    distance = {}
    visited = {}
    distance[(source[0], source[1])] = 0

    heap = [(0, source[0], source[1])]
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    while len(heap) &gt; 0:
        dist, curr_x, curr_y = heapq.heappop(heap)

        if (curr_x, curr_y) in visited:
            continue

        visited[(curr_x, curr_y)] = True

        for (_x, _y) in dirs:
            new_x = curr_x + _x
            new_y = curr_y + _y

            if (new_x, new_y) in visited:
                continue

            if 0 &lt;= new_x &lt; rows_length and 0 &lt;= new_y &lt; cols_length and dist + graph[new_x][new_y] &lt; distance.get((new_x, new_y), float('inf')):
                distance[(new_x, new_y)] = dist + graph[new_x][new_y]
                heapq.heapappend(heap, (dist + graph[new_x][new_y], new_x, new_y))
    print(distance)
</code></pre>
<p>All Pairs Shortest Path
1. Bellman Ford's Algo</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
